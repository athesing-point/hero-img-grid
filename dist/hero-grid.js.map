{
  "version": 3,
  "sources": ["../hero-grid.js"],
  "sourcesContent": ["// Wait for the DOM to be fully loaded\ndocument.addEventListener(\"DOMContentLoaded\", (event) => {\n  // Ensure GSAP and ScrollTrigger are loaded\n  if (typeof gsap !== \"undefined\" && typeof ScrollTrigger !== \"undefined\") {\n    gsap.registerPlugin(ScrollTrigger);\n\n    // Select elements needed later\n    const heroSection = document.querySelector(\".hero-section\");\n    const allWraps = gsap.utils.toArray(\".hero-img-mask-wrap\");\n    const specialElements = document.querySelectorAll(\".pq-route, .video-trigger\");\n    // const mouseParallaxIntensity = 10; // REMOVED\n    // const wrapData = []; // REMOVED\n\n    // --- Function to Initialize ScrollTrigger Parallax ---\n    function initializeScrollTrigger() {\n      console.log(\"Attempting to initialize ScrollTrigger parallax...\");\n      const scrollParallaxSpeeds = { col1: -25, col2: -50, col3: -75, col4: -100 };\n\n      // Animate columns\n      Object.keys(scrollParallaxSpeeds).forEach((colKey, index) => {\n        const colNum = index + 1;\n        const speed = scrollParallaxSpeeds[colKey];\n        const targetSelector = `.hero-bg-grid [id$=\"-col${colNum}\"]`;\n        const targets = gsap.utils.toArray(targetSelector);\n        console.log(`Found ${targets.length} elements for selector: ${targetSelector}`);\n\n        if (targets.length > 0) {\n          gsap.to(targets, {\n            yPercent: speed,\n            ease: \"none\",\n            scrollTrigger: {\n              trigger: \".hero-section\",\n              start: \"top top\",\n              end: \"bottom top\",\n              scrub: 1,\n              markers: false,\n              invalidateOnRefresh: true,\n              anticipatePin: 1,\n            },\n          });\n\n          // --- REMOVED: Animate image within col1 to reveal ---\n          // --- END REMOVED ---\n        } else {\n          console.log(\"No elements found for selector: \" + targetSelector);\n        }\n      });\n\n      // Refresh ScrollTrigger once after setting up all tweens, with a tiny delay (REMOVED - Refresh now happens in animationend listener)\n      /*\n      setTimeout(() => {\n        console.log(\"Refreshing ScrollTrigger...\");\n        ScrollTrigger.refresh();\n      }, 100);\n      */\n    }\n\n    // --- GSAP Initial Entrance Animation --- (REMOVED)\n    /*\n    // Set initial state (hidden)\n    // Note: Initial state also set in hero-grid.css to prevent FOUC\n    gsap.set(allWraps, { opacity: 0, y: 20 });\n\n    // Animate to final state (visible)\n    gsap.to(allWraps, {\n      opacity: 1,\n      y: 0,\n      duration: 0.6, // Using the faster duration from before\n      stagger: 0.07, // Using the faster stagger from before\n      ease: \"power2.out\",\n      delay: 0, // Start animation sooner for LCP/FCP\n      onComplete: () => {\n        console.log(\"GSAP entrance animation complete.\");\n        // Initialize ScrollTrigger Parallax ONLY AFTER entrance animation finishes\n        initializeScrollTrigger();\n      },\n    });\n    */\n\n    // Initialize ScrollTrigger Parallax directly (REMOVED - Now waits for CSS animation)\n    // initializeScrollTrigger();\n\n    // --- Wait for CSS Animation to End Before Initializing Parallax ---\n    const wraps = gsap.utils.toArray(\".hero-img-mask-wrap\");\n    const lastWrap = wraps.length > 0 ? wraps[wraps.length - 1] : null;\n\n    if (lastWrap) {\n      console.log(\"Waiting for animation end on:\", lastWrap);\n      lastWrap.addEventListener(\n        \"animationend\",\n        () => {\n          console.log(\"CSS animation ended on last element. Initializing ScrollTrigger.\");\n          initializeScrollTrigger();\n          console.log(\"Refreshing ScrollTrigger immediately after setup...\");\n          ScrollTrigger.refresh(); // Refresh immediately after setup\n        },\n        { once: true }\n      ); // Ensure listener runs only once\n    } else {\n      console.log(\"No .hero-img-mask-wrap found, initializing ScrollTrigger immediately.\");\n      // Fallback if no wraps found\n      initializeScrollTrigger();\n      ScrollTrigger.refresh(); // Also refresh in fallback\n    }\n\n    // --- SVG Arrow Drawing Animation ---\n    function initializeArrowAnimation() {\n      const arrowSvg = document.querySelector(\"#hero-arrow-svg\");\n      if (!arrowSvg) {\n        console.log(\"Arrow SVG (#hero-arrow-svg) not found. Skipping animation. Ensure it's embedded inline.\");\n        return;\n      }\n      const arrowPathMain = arrowSvg.querySelector(\"#arrow-path-main\");\n      const arrowPathHead = arrowSvg.querySelector(\"#arrow-path-head\");\n\n      if (!arrowPathMain || !arrowPathHead) {\n        console.log(\"Arrow paths (#arrow-path-main or #arrow-path-head) not found within the SVG.\");\n        return;\n      }\n\n      // Get lengths of paths\n      const mainLength = arrowPathMain.getTotalLength();\n      const headLength = arrowPathHead.getTotalLength();\n\n      // Store the original dash array value from the main path\n      const originalDasharray = arrowPathMain.getAttribute(\"stroke-dasharray\") || \"none\"; // Fallback to none\n\n      // Set initial state: hide paths by making dash offset equal to length\n      // Temporarily set dasharray to full length to make it solid for the draw animation\n      gsap.set([arrowPathMain, arrowPathHead], {\n        strokeDasharray: (i, target) => target.getTotalLength(), // Solid line = dash = length\n        strokeDashoffset: (i, target) => target.getTotalLength(), // Offset = length (hidden)\n        autoAlpha: 1, // Ensure paths are visible once drawn\n      });\n\n      // Create timeline for drawing animation triggered by scroll\n      const arrowTl = gsap.timeline({\n        scrollTrigger: {\n          trigger: arrowSvg,\n          start: \"top 85%\", // Start animation when 85% of the SVG top hits the viewport bottom\n          end: \"bottom 60%\", // Adjust timing as needed\n          scrub: 1, // Smooth scrubbing effect\n          // markers: true, // Uncomment for debugging ScrollTrigger bounds\n        },\n      });\n\n      // Animate the drawing (solid line appears)\n      arrowTl\n        .to(arrowPathMain, { strokeDashoffset: 0, duration: 2, ease: \"power1.inOut\" })\n        .to(arrowPathHead, { strokeDashoffset: 0, duration: 1, ease: \"power1.inOut\" }, \"-=1.2\")\n        // After drawing, instantly set the main path back to its original dasharray\n        .set(arrowPathMain, { strokeDasharray: originalDasharray }, \">\"); // \">\" places it at the very end\n    }\n\n    // Call the arrow animation setup function\n    // Ensure this is called after potential waits (like animationend) if needed,\n    // but for now, let's try calling it directly after mouse interactions setup.\n    // Now that ScrollTrigger init is delayed, ensure this isn't called too early if it depends on ScrollTrigger's setup.\n    // However, this specific arrow animation seems independent or triggers later, so likely okay here.\n    // If the arrow SVG is part of the initially animated grid, it might need adjustment.\n    initializeArrowAnimation();\n  } else {\n    console.error(\"GSAP or ScrollTrigger is not loaded.\");\n  }\n});\n"],
  "mappings": "MACA,SAAS,iBAAiB,mBAAqBA,GAAU,CAEvD,GAAI,OAAO,KAAS,KAAe,OAAO,cAAkB,IAAa,CAWvE,IAASC,EAAT,UAAmC,CACjC,QAAQ,IAAI,oDAAoD,EAChE,IAAMC,EAAuB,CAAE,KAAM,IAAK,KAAM,IAAK,KAAM,IAAK,KAAM,IAAK,EAG3E,OAAO,KAAKA,CAAoB,EAAE,QAAQ,CAACC,EAAQC,IAAU,CAC3D,IAAMC,EAASD,EAAQ,EACjBE,EAAQJ,EAAqBC,CAAM,EACnCI,EAAiB,2BAA2BF,CAAM,KAClDG,EAAU,KAAK,MAAM,QAAQD,CAAc,EACjD,QAAQ,IAAI,SAASC,EAAQ,MAAM,2BAA2BD,CAAc,EAAE,EAE1EC,EAAQ,OAAS,EACnB,KAAK,GAAGA,EAAS,CACf,SAAUF,EACV,KAAM,OACN,cAAe,CACb,QAAS,gBACT,MAAO,UACP,IAAK,aACL,MAAO,EACP,QAAS,GACT,oBAAqB,GACrB,cAAe,CACjB,CACF,CAAC,EAKD,QAAQ,IAAI,mCAAqCC,CAAc,CAEnE,CAAC,CASH,EAmDSE,EAAT,UAAoC,CAClC,IAAMC,EAAW,SAAS,cAAc,iBAAiB,EACzD,GAAI,CAACA,EAAU,CACb,QAAQ,IAAI,yFAAyF,EACrG,MACF,CACA,IAAMC,EAAgBD,EAAS,cAAc,kBAAkB,EACzDE,EAAgBF,EAAS,cAAc,kBAAkB,EAE/D,GAAI,CAACC,GAAiB,CAACC,EAAe,CACpC,QAAQ,IAAI,8EAA8E,EAC1F,MACF,CAGA,IAAMC,EAAaF,EAAc,eAAe,EAC1CG,EAAaF,EAAc,eAAe,EAG1CG,EAAoBJ,EAAc,aAAa,kBAAkB,GAAK,OAI5E,KAAK,IAAI,CAACA,EAAeC,CAAa,EAAG,CACvC,gBAAiB,CAACI,EAAGC,IAAWA,EAAO,eAAe,EACtD,iBAAkB,CAACD,EAAGC,IAAWA,EAAO,eAAe,EACvD,UAAW,CACb,CAAC,EAGe,KAAK,SAAS,CAC5B,cAAe,CACb,QAASP,EACT,MAAO,UACP,IAAK,aACL,MAAO,CAET,CACF,CAAC,EAIE,GAAGC,EAAe,CAAE,iBAAkB,EAAG,SAAU,EAAG,KAAM,cAAe,CAAC,EAC5E,GAAGC,EAAe,CAAE,iBAAkB,EAAG,SAAU,EAAG,KAAM,cAAe,EAAG,OAAO,EAErF,IAAID,EAAe,CAAE,gBAAiBI,CAAkB,EAAG,GAAG,CACnE,EA1IS,IAAAd,IA4FAQ,IAtGT,KAAK,eAAe,aAAa,EAGjC,IAAMS,EAAc,SAAS,cAAc,eAAe,EACpDC,EAAW,KAAK,MAAM,QAAQ,qBAAqB,EACnDC,EAAkB,SAAS,iBAAiB,2BAA2B,EA0EvEC,EAAQ,KAAK,MAAM,QAAQ,qBAAqB,EAChDC,EAAWD,EAAM,OAAS,EAAIA,EAAMA,EAAM,OAAS,CAAC,EAAI,KAE1DC,GACF,QAAQ,IAAI,gCAAiCA,CAAQ,EACrDA,EAAS,iBACP,eACA,IAAM,CACJ,QAAQ,IAAI,kEAAkE,EAC9ErB,EAAwB,EACxB,QAAQ,IAAI,qDAAqD,EACjE,cAAc,QAAQ,CACxB,EACA,CAAE,KAAM,EAAK,CACf,IAEA,QAAQ,IAAI,uEAAuE,EAEnFA,EAAwB,EACxB,cAAc,QAAQ,GA0DxBQ,EAAyB,CAC3B,MACE,QAAQ,MAAM,sCAAsC,CAExD,CAAC",
  "names": ["event", "initializeScrollTrigger", "scrollParallaxSpeeds", "colKey", "index", "colNum", "speed", "targetSelector", "targets", "initializeArrowAnimation", "arrowSvg", "arrowPathMain", "arrowPathHead", "mainLength", "headLength", "originalDasharray", "i", "target", "heroSection", "allWraps", "specialElements", "wraps", "lastWrap"]
}
